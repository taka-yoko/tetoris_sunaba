# 初期化処理
fallCount -> 0
memory[55001] -> 1
drawWallAndBottom()
makeCiclePattern()
x -> 5
y -> 1
c -> 0
k -> 0
preLeft  -> memory[50006]
preRight -> memory[50007]
preUp    -> memory[50004]

# テスト用
# delete_test()

# ループ処理
while 0 < 1
  curLeft  -> memory[50006]
  curRight -> memory[50007]
  curUp    -> memory[50004]
  x_move -> 0
  y_move -> 0
  c_move -> 0
  # キーが連続で押されていなければ移動
  if (curLeft = 1) * (preLeft = 0)
    x_move -> -1
  if (curRight = 1) * (preRight = 0)
    x_move -> 1
  if (curUp = 1) * (preUp = 0)
    c_move -> 1
  preLeft  -> curLeft
  preRight -> curRight
  preUp    -> curUp
  # fallCount（落ちるスピードの調整）
  fallCount -> fallCount + 1
  if fallCount >= 10
    y_move -> 1
    fallCount -> 0
  # 移動を反映
  x -> x + x_move
  y -> y + y_move
  c -> c + c_move
  # 四角に重なっていれば
  if overlapped?(x, y, c, k)
    # 戻す
    x -> x - x_move
    y -> y - y_move
    c -> c - c_move
    # 縦移動量が0より多く、斜め移動でなければ積もらせる
    if (y_move > 0) * (x_move = 0)
      drawAndDeleteSquare(x, y, c, k)
      x -> 5
      y -> 1
      c -> 0
      k -> 1 - k
  moveSquare(x, y, c, k)

###########################
# 関数
###########################

# 四角を描く
def drawSquare(x, y, color)
  i -> 0
  while i < 4
      j -> 0
      while j < 4 
          memory[60000 + (y * 500) + (x * 5) + (i * 100) + j] -> color
          j -> j + 1
      i -> i + 1

# 両側の壁を描く
def drawWall()
  y -> 0
  while y < 20
    # 両側の壁のマッピングと四角の描画
    map_and_draw(0, y)
    map_and_draw(11, y)
    y -> y + 1

# 底を描く
def drawBottom()
  x -> 0
  while x < 11
    # 底のマッピングと四角の描画
    map_and_draw(x, 19)
    x -> x + 1

# 両側の壁と底を一度に描く
def drawWallAndBottom()
  drawWall()
  drawBottom()

# 四角のマッピングと描画
def map_and_draw(x, y)
  memory[100 + (y * 12) + x] -> 1
  drawSquare(x, y, 999999)

# 四角のマッピングと削除
def map_and_delete(x, y)
  memory[100 + (y * 12) + x] -> 0
  drawSquare(x, y, 0)

# 列が埋まっていれば消す
def deleteSquare()
  y -> 0
  while y < 19
    # 列が埋まっているかの判定
    delete? -> 1
    x -> 1
    while x < 11
      delete? -> delete? * memory[100 + (y * 12) + x] = 1
      x -> x + 1
    # 列が埋まっていれば
    if delete?
      # 列を黒くする
      x -> 1
      while x < 11
        map_and_delete(x, y)
        x -> x + 1
      # ずらす
      moveUpwardBlock(y)
    y -> y + 1

# ずらす
def moveUpwardBlock(y)
  while y > 1
    x -> 1
    while x < 11
      if memory[100 + ((y - 1) * 12) + x] = 1
        map_and_delete(x, y-1)
        map_and_draw(x, y)
      x -> x + 1
    y -> y - 1

# 積もらせて列を消す
def drawAndDeleteSquare(x, y, c, k)
  calcPosition(x, y, c, k)
  # 積もる（マッピング処理と四角描画）
  map_and_draw(memory[0], memory[1])
  map_and_draw(memory[2], memory[3])
  map_and_draw(memory[4], memory[5])
  # 行が揃っていれば消す
  deleteSquare()

# 四角を動かす
def moveSquare(x, y, c, k)
  calcPosition(x, y, c, k)
  drawSquare(memory[0], memory[1], 990000)
  drawSquare(memory[2], memory[3], 990000)
  drawSquare(memory[4], memory[5], 990000)
  memory[55000] -> 1
  drawSquare(memory[0], memory[1], 0)
  drawSquare(memory[2], memory[3], 0)
  drawSquare(memory[4], memory[5], 0)

# 重なっているかの判定
def overlapped?(x, y, c, k)
  calcPosition(x, y, c, k)
  out -> (memory[100 + (memory[1] * 12) + memory[0]] = 1) +
  (memory[100 + (memory[3] * 12) + memory[2]] = 1) +
  (memory[100 + (memory[5] * 12) + memory[4]] = 1)

# マス目位置を計算
def calcPosition(x, y, c, k)
  if c > 3
    c -> 3
  memory[0] -> x
  memory[1] -> y
  start -> 500 + (k * 16) + (c * 4)
  memory[2] -> x + memory[start + 0]
  memory[3] -> y + memory[start + 1]
  memory[4] -> x + memory[start + 2]
  memory[5] -> y + memory[start + 3]

def makeCiclePattern()
  setMemory(500,  1,  0, -1,  0)
  setMemory(504,  0,  1,  0, -1)
  setMemory(508, -1,  0,  1,  0)
  setMemory(512,  0, -1,  0,  1)
  setMemory(516,  1,  0,  0, -1)
  setMemory(520,  0,  1,  1,  0)
  setMemory(524, -1,  0,  0,  1)
  setMemory(528,  0, -1, -1,  0)

def setMemory(start, n0, n1, n2, n3)
  memory[start + 0] -> n0
  memory[start + 1] -> n1
  memory[start + 2] -> n2
  memory[start + 3] -> n3

# 列を消すテスト用の状態を作成するメソッド
def delete_test()
  test_y -> 10
  while test_y < 19
    test_x -> 1
    while test_x < 11
      if test_x != 5
        map_and_draw(test_x, test_y)
      test_x -> test_x + 1
    test_y -> test_y + 1
